---
title: "Introduction to Importing Data in R"
output: html_notebook
---

# Chapter 1: Importing data from flat files with `utils`

## Video 1.1: Introduction & `read.csv`

5 types of files:

1.  **Flat files**: simple text files that display data as tables

2.  Data from Excel

3.  Databases

4.  Web

5.  Statistical software

### `utils` - `read.csv`

-   Loaded by default when you start R

```{r}
read.csv("datasets/states.csv")
```

-   What if file in datasets folder of home directory (`~`)?

```{r}
path <- file.path("datasets/states.csv")
```

-   Can now use `path` within `read.csv`:

```{r}
read.csv(path)
```

## **read.csv**

The `utils` package, which is automatically loaded in your R session on startup, can import CSV files with the `read.csv()` function.

In this exercise, you'll be working with `swimming_pools.csv` ([**view**](http://assets.datacamp.com/production/course_1477/datasets/swimming_pools.csv)); it contains data on swimming pools in Brisbane, Australia. The file contains the column names in the first row. It uses a comma to separate values within rows.

Type `dir()` in the console to list the files in your working directory. You'll see that it contains `swimming_pools.csv`, so you can start straight away.

**Instructions**

-   Use `read.csv()` to import `"swimming_pools.csv"`, which is located in the current directory, as a data frame with the name `pools`.

-   Print the structure of `pools` using `str()`.

```{r}
# Import swimming_pools.csv: pools
pools <- read.csv("datasets/swimming_pools.csv")

# Print the structure of pools
str(pools)
```

## Video 1.2: `read.delim` & `read.table`

### Tab-delimited file

-   Import with `read.delim`

```{r}
read.delim("datasets/states.txt")
```

### Exotic file format

```         
# 
# state/capital/pop_mill/area_sqm
# South Dakota/Pierre/0.853/77116
# New York/Albany/19.746/54555
# Oregon/Salem/3.970/98381
# Vermont/Montpelier/0.627/9616
# Hawaii/Honolulu/1.420/10931
```

### `read.table()`

-   Read any tabular file as a data frame

-   Number of arguments is huge

```{r}
# Read data with the first row as column headers
read.table("datasets/states2.txt", 
           header = TRUE, 
           sep = "/")
```

## **read.delim**

Aside from `.csv` files, there are also the `.txt` files which are basically text files. You can import these files with `read.delim()`. By default, it sets the `sep` argument to `"\t"` (fields in a record are delimited by tabs) and the `header` argument to `TRUE` (the first row contains the field names).

In this exercise, you will import `hotdogs.txt` ([**view**](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/hotdogs.txt)), containing information on sodium and calorie levels in different hotdogs (Source: [**UCLA**](http://wiki.stat.ucla.edu/socr/index.php/SOCR_012708_ID_Data_HotDogs)). The dataset has 3 variables, but the variable names are *not* available in the first line of the file. The file uses tabs as field separators.

**Instructions**

-   Import `"hotdogs.txt"` with `read.delim()`. Call the resulting data frame `hotdogs`. The variable names are **not** on the first line, so make sure to set the `header` argument appropriately.

-   Call `summary()` on `hotdogs`. This will print out some summary statistics about all variables in the data frame.

```{r}
# Import hotdogs.txt: hotdogs
hotdogs <- read.delim("datasets/hotdogs.txt", 
                      header = FALSE)

# Summarize hotdogs
summary(hotdogs)
```

## **Assigning column names**

You’ve probably noticed that the `hotdogs.txt` file lacks column names, and R has assigned default, random names to the columns.

To make the data more understandable and easier to work with, you can assign appropriate column names while reading the file into R.

```         
head(hotdogs)     
   V1  V2  V3 
1 Beef 186 495 
2 Beef 181 477 
3 Beef 176 425 
4 Beef 149 322 
5 Beef 184 482 
6 Beef 190 587 
```

**Instructions**

-   Complete the `read.delim()` function call by assigning the column names to "type", "calories", and "sodium".

```{r}
# Finish the read.delim() call
hotdogs <- read.delim("datasets/hotdogs.txt", 
                      header = FALSE, 
                      col.names = c("type", 
                                    "calories", 
                                    "sodium")
                      )

# Select the hot dog with the least calories: lily
lily <- hotdogs[which.min(hotdogs$calories), ]

# Select the observation with the most sodium: tom
tom <- hotdogs[which.max(hotdogs$sodium), ]

# Print lily and tom
lily
tom
```

## **Column classes**

The `colClasses` argument allows you to specify the data types for each column of the file you are reading. This can improve the efficiency of the import process and ensure that the columns are read in with the correct data types.

You can do this by setting the `colClasses` argument:

```         
read.delim("my_file.txt",             colClasses = c("character",                           "numeric",                           "logical")) 
```

If a column is set to `"NULL"` in the `colClasses` vector, this column will be skipped and will not be loaded into the data frame.

**Instructions**

-   The `hotdogs` data frame has been loaded. Go ahead and display the structure of `hotdogs`.

-   In the `colClasses` argument of the second `read.delim()` call, set the first, second, and third columns to `'character'`, `'NULL'` and `'numeric'`.

-   Display the structure of `hotdogs2` and look for the difference.

```{r}
# Previous call to import hotdogs.txt
hotdogs <- read.delim("datasets/hotdogs.txt", 
                      header = FALSE, 
                      col.names = c("type", 
                                    "calories", 
                                    "sodium")
                      )

# Display structure of hotdogs
str(hotdogs)

# Edit the colClasses argument to import the data correctly: hotdogs2
hotdogs2 <- read.delim("datasets/hotdogs.txt", 
                       header = FALSE, 
                       col.names = c("type", 
                                     "calories", 
                                     "sodium"),
                       colClasses = c("factor", 
                                      "NULL", 
                                      "numeric"))


# Display structure of hotdogs2
str(hotdogs2)
```

## **`read.table`**

If you're dealing with more exotic flat file formats, you'll want to use `read.table()`. It's the most basic importing function; you can specify tons of different arguments in this function. Unlike `read.csv()` and `read.delim()`, the `header` argument defaults to `FALSE` and the `sep` argument is `""` by default.

Up to you again! The data is still `hotdogs.txt` ([**view**](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/hotdogs.txt)). It has no column names in the first row, and the field separators are tabs. This time, though, the file is in the `data` folder inside your current working directory. A variable `path` with the location of this file is already coded for you.

**Instructions**

-   Finish the `read.table()` call to load the *tab-delimited* file found at `path`.

-   Call `head()` on `hotdogs`; this will print the first 6 observations in the data frame.

```{r}
# Path to the hotdogs.txt file: path
path <- file.path("datasets", "hotdogs.txt")

# Import the hotdogs.txt file: hotdogs
hotdogs <- read.table(path, 
                      sep = "\t", 
                      col.names = c("type", "calories", "sodium"))

# Call head() on hotdogs
head(hotdogs)
```

## Video 1.3: Final Thoughts

### Wrappers

-   `read.table()` is the main function

-   `read.csv()` = wrapper for CSV

-   `read.delim()` = wrapper for tab-delimited files

### `read.csv()`

-   Defaults

    -   `header = TRUE`

    -   `sep = ","`

```{r}
read.table("datasets/states.csv", 
           header = TRUE, 
           sep = ",")
```

```{r}
read.csv("datasets/states.csv")
```

### `read.delim()`

-   Defaults:

    -   `header = TRUE`

    -   `sep = "\t"`

### Documentation

```{r}
?read.table
```

### Locale differences

`read.csv` and `read.csv2` are identical to `read.table` except for the defaults. They are intended for reading ‘comma separated value’ files (‘.csv’) or (`read.csv2`) the variant used in countries that use a comma as decimal point and a semicolon as field separator.

Similarly, `read.delim` and `read.delim2` are for reading delimited files, defaulting to the TAB character for the delimiter. Notice that `header = TRUE` and `fill = TRUE` in these variants, and that the comment character is disabled.

```{r}
read.csv("datasets/states_aye.csv",
         header = TRUE,
         sep = ",",
         quote = "\"",
         dec = ".",
         fill = TRUE,
         comment.char = "")
```

```{r}
read.csv2("datasets/states_nay.csv",
         header = TRUE,
         sep = ";",
         quote = "\"",
         dec = ",",
         fill = TRUE,
         comment.char = "")
```

```{r}
read.delim("datasets/states.txt",
         header = TRUE,
         sep = "\t",
         quote = "\"",
         dec = ".",
         fill = TRUE,
         comment.char = "")
```

```{r}
# read.delim2(file,
#          header = TRUE,
#          sep = "\t",
#          quote = "\"",
#          dec = ",",
#          fill = TRUE,
#          comment.char = "")
```

| Function      | Package | Purpose                           |
|---------------|---------|-----------------------------------|
| `read.csv`    | `utils` | `,` separator using `.` decimal   |
| `read.csv2`   | `utils` | `;` separator using `,` decimal   |
| `read.delim`  | `utils` | `tab` separator using `.` decimal |
| `read.delim2` | `utils` | `tab` separator using `,` decimal |

: Functions to accomodate locale differences when importing flat files.

------------------------------------------------------------------------

## `utils::read.table Documentation`

### Description

Reads a file in table format and creates a data frame from it, with cases corresponding to lines and variables to fields in the file.

### Usage

```{r}
# read.table(file,
#            header = FALSE, 
#            sep = "",
#            quote = "\"'",
#            dec = ".", 
#            numerals = c("allow.loss", "warn.loss", "no.loss"),            
#            row.names, 
#            col.names, 
#            as.is = !stringsAsFactors, 
#            tryLogical = TRUE,            
#            na.strings = "NA", 
#            colClasses = NA, 
#            nrows = -1,            
#            skip = 0, 
#            check.names = TRUE, 
#            fill = !blank.lines.skip,            
#            strip.white = FALSE, 
#            blank.lines.skip = TRUE,
#            comment.char = "#",    
#            allowEscapes = FALSE, 
#            flush = FALSE,            
#            stringsAsFactors = FALSE,
#            fileEncoding = "",
#            encoding = "unknown", 
#            text, 
#            skipNul = FALSE
#        )  
# 
# read.csv(file, header = TRUE, sep = ",", quote = "\"", dec = ".", fill = TRUE, comment.char = "", ...)  
# 
# read.csv2(file, header = TRUE, sep = ";", quote = "\"", dec = ",", fill = TRUE, comment.char = "", ...)  
# 
# read.delim(file, header = TRUE, sep = "\t", quote = "\"", dec = ".", fill = TRUE, comment.char = "", ...)  
# 
# read.delim2(file, header = TRUE, sep = "\t", quote = "\"", dec = ",", fill = TRUE, comment.char = "", ...) 
```

```         
```

### Arguments

+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `file`             | the name of the file which the data are to be read from. Each row of the table appears as one line of the file. If it does not contain an *absolute* path, the file name is *relative* to the current working directory, [`getwd`](http://127.0.0.1:45439/help/library/utils/help/getwd)`()`. Tilde-expansion is performed where supported. This can be a compressed file (see [`file`](http://127.0.0.1:45439/help/library/utils/help/file)).                                                                                                                                                         |
|                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|                    | Alternatively, `file` can be a readable text-mode [connection](http://127.0.0.1:45439/help/library/utils/help/connection) (which will be opened for reading if necessary, and if so [`close`](http://127.0.0.1:45439/help/library/utils/help/close)d (and hence destroyed) at the end of the function call). (If [`stdin`](http://127.0.0.1:45439/help/library/utils/help/stdin)`()` is used, the prompts for lines may be somewhat confusing. Terminate input with a blank line or an EOF signal, `Ctrl-D` on Unix and `Ctrl-Z` on Windows. Any pushback on `stdin()` will be cleared before return.) |
|                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|                    | `file` can also be a complete URL. (For the supported URL schemes, see the ‘URLs’ section of the help for [`url`](http://127.0.0.1:45439/help/library/utils/help/url).)                                                                                                                                                                                                                                                                                                                                                                                                                                |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `header`           | a logical value indicating whether the file contains the names of the variables as its first line. If missing, the value is determined from the file format: `header` is set to `TRUE` if and only if the first row contains one fewer field than the number of columns.                                                                                                                                                                                                                                                                                                                               |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `sep`              | the field separator character. Values on each line of the file are separated by this character. If `sep = ""` (the default for `read.table`) the separator is ‘white space’, that is one or more spaces, tabs, newlines or carriage returns.                                                                                                                                                                                                                                                                                                                                                           |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `quote`            | the set of quoting characters. To disable quoting altogether, use `quote = ""`. See [`scan`](http://127.0.0.1:45439/help/library/utils/help/scan) for the behaviour on quotes embedded in quotes. Quoting is only considered for columns read as character, which is all of them unless `colClasses` is specified.                                                                                                                                                                                                                                                                                     |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `dec`              | the character used in the file for decimal points.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `numerals`         | string indicating how to convert numbers whose conversion to double precision would lose accuracy, see [`type.convert`](http://127.0.0.1:45439/help/library/utils/help/type.convert). Can be abbreviated. (Applies also to complex-number inputs.)                                                                                                                                                                                                                                                                                                                                                     |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `row.names`        | a vector of row names. This can be a vector giving the actual row names, or a single number giving the column of the table which contains the row names, or character string giving the name of the table column containing the row names.                                                                                                                                                                                                                                                                                                                                                             |
|                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|                    | If there is a header and the first row contains one fewer field than the number of columns, the first column in the input is used for the row names. Otherwise if `row.names` is missing, the rows are numbered.                                                                                                                                                                                                                                                                                                                                                                                       |
|                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|                    | Using `row.names = NULL` forces row numbering. Missing or `NULL` `row.names` generate row names that are considered to be ‘automatic’ (and not preserved by [`as.matrix`](http://127.0.0.1:45439/help/library/utils/help/as.matrix)).                                                                                                                                                                                                                                                                                                                                                                  |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `col.names`        | a vector of optional names for the variables. The default is to use `"V"` followed by the column number.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `as.is`            | controls conversion of character variables (insofar as they are not converted to logical, numeric or complex) to factors, if not otherwise specified by `colClasses`. Its value is either a vector of logicals (values are recycled if necessary), or a vector of numeric or character indices which specify which columns should not be converted to factors.                                                                                                                                                                                                                                         |
|                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|                    | Note: to suppress all conversions including those of numeric columns, set `colClasses = "character"`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|                    | Note that `as.is` is specified per column (not per variable) and so includes the column of row names (if any) and any columns to be skipped.                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `tryLogical`       | a [`logical`](http://127.0.0.1:45439/help/library/utils/help/logical) determining if columns consisting entirely of `"F"`, `"T"`, `"FALSE"`, and `"TRUE"` should be converted to [`logical`](http://127.0.0.1:45439/help/library/utils/help/logical); passed to [`type.convert`](http://127.0.0.1:45439/help/library/utils/help/type.convert), true by default.                                                                                                                                                                                                                                        |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `na.strings`       | a character vector of strings which are to be interpreted as [`NA`](http://127.0.0.1:45439/help/library/utils/help/NA) values. Blank fields are also considered to be missing values in logical, integer, numeric and complex fields. Note that the test happens *after* white space is stripped from the input (if enabled), so `na.strings` values may need their own white space stripped in advance.                                                                                                                                                                                               |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `colClasses`       | character. A vector of classes to be assumed for the columns. If unnamed, recycled as necessary. If named, names are matched with unspecified values being taken to be `NA`.                                                                                                                                                                                                                                                                                                                                                                                                                           |
|                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|                    | Possible values are `NA` (the default, when [`type.convert`](http://127.0.0.1:45439/help/library/utils/help/type.convert) is used), `"NULL"` (when the column is skipped), one of the atomic vector classes (logical, integer, numeric, complex, character, raw), or `"factor"`, `"Date"` or `"POSIXct"`. Otherwise there needs to be an `as` method (from package **methods**) for conversion from `"character"` to the specified formal class.                                                                                                                                                       |
|                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|                    | Note that `colClasses` is specified per column (not per variable) and so includes the column of row names (if any).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `nrows`            | integer: the maximum number of rows to read in. Negative and other invalid values are ignored.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `skip`             | integer: the number of lines of the data file to skip before beginning to read data.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `check.names`      | logical. If `TRUE` then the names of the variables in the data frame are checked to ensure that they are syntactically valid variable names. If necessary they are adjusted (by [`make.names`](http://127.0.0.1:45439/help/library/utils/help/make.names)) so that they are, and also to ensure that there are no duplicates.                                                                                                                                                                                                                                                                          |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `fill`             | logical. If `TRUE` then in case the rows have unequal length, blank fields are implicitly added. See ‘Details’.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `strip.white`      | logical. Used only when `sep` has been specified, and allows the stripping of leading and trailing white space from unquoted `character` fields (`numeric` fields are always stripped). See [`scan`](http://127.0.0.1:45439/help/library/utils/help/scan) for further details (including the exact meaning of ‘white space’), remembering that the columns may include the row names.                                                                                                                                                                                                                  |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `blank.lines.skip` | logical: if `TRUE` blank lines in the input are ignored.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `comment.char`     | character: a character vector of length one containing a single character or an empty string. Use `""` to turn off the interpretation of comments altogether.                                                                                                                                                                                                                                                                                                                                                                                                                                          |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `allowEscapes`     | logical. Should C-style escapes such as ‘⁠\\n⁠’ be processed or read verbatim (the default)? Note that if not within quotes these could be interpreted as a delimiter (but not as a comment character). For more details see [`scan`](http://127.0.0.1:45439/help/library/utils/help/scan).                                                                                                                                                                                                                                                                                                              |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `flush`            | logical: if `TRUE`, `scan` will flush to the end of the line after reading the last of the fields requested. This allows putting comments after the last field.                                                                                                                                                                                                                                                                                                                                                                                                                                        |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `stringsAsFactors` | logical: should character vectors be converted to factors? Note that this is overridden by `as.is` and `colClasses`, both of which allow finer control.                                                                                                                                                                                                                                                                                                                                                                                                                                                |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `fileEncoding`     | character string: if non-empty declares the encoding used on a file when given as a character string (not on an existing connection) so the character data can be re-encoded. See the ‘Encoding’ section of the help for [`file`](http://127.0.0.1:45439/help/library/utils/help/file), the ‘R Data Import/Export’ manual and ‘Note’.                                                                                                                                                                                                                                                                  |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `encoding`         | encoding to be assumed for input strings. It is used to mark character strings as known to be in Latin-1 or UTF-8 (see [`Encoding`](http://127.0.0.1:45439/help/library/utils/help/Encoding)): it is not used to re-encode the input, but allows **R** to handle encoded strings in their native encoding (if one of those two). See ‘Value’ and ‘Note’.                                                                                                                                                                                                                                               |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `text`             | character string: if `file` is not supplied and this is, then data are read from the value of `text` via a text connection. Notice that a literal string can be used to include (small) data sets within R code.                                                                                                                                                                                                                                                                                                                                                                                       |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `skipNul`          | logical: should NULs be skipped?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `...`              | Further arguments to be passed to `read.table`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

### Details

This function is the principal means of reading tabular data into **R**.

Unless `colClasses` is specified, all columns are read as character columns and then converted using [`type.convert`](http://127.0.0.1:45439/help/library/utils/help/type.convert) to logical, integer, numeric, complex or (depending on `as.is`) factor as appropriate. Quotes are (by default) interpreted in all fields, so a column of values like `"42"` will result in an integer column.

A field or line is ‘blank’ if it contains nothing (except whitespace if no separator is specified) before a comment character or the end of the field or line.

If `row.names` is not specified and the header line has one less entry than the number of columns, the first column is taken to be the row names. This allows data frames to be read in from the format in which they are printed. If `row.names` is specified and does not refer to the first column, that column is discarded from such files.

The number of data columns is determined by looking at the first five lines of input (or the whole input if it has less than five lines), or from the length of `col.names` if it is specified and is longer. This could conceivably be wrong if `fill` or `blank.lines.skip` are true, so specify `col.names` if necessary (as in the ‘Examples’).

`read.csv` and `read.csv2` are identical to `read.table` except for the defaults. They are intended for reading ‘comma separated value’ files (‘.csv’) or (`read.csv2`) the variant used in countries that use a comma as decimal point and a semicolon as field separator. Similarly, `read.delim` and `read.delim2` are for reading delimited files, defaulting to the TAB character for the delimiter. Notice that `header = TRUE` and `fill = TRUE` in these variants, and that the comment character is disabled.

The rest of the line after a comment character is skipped; quotes are not processed in comments. Complete comment lines are allowed provided `blank.lines.skip = TRUE`; however, comment lines prior to the header must have the comment character in the first non-blank column.

Quoted fields with embedded newlines are supported except after a comment character. Embedded NULs are unsupported: skipping them (with `skipNul = TRUE`) may work.

### Value

A data frame ([`data.frame`](http://127.0.0.1:45439/help/library/utils/help/data.frame)) containing a representation of the data in the file.

Empty input is an error unless `col.names` is specified, when a 0-row data frame is returned: similarly giving just a header line if `header = TRUE` results in a 0-row data frame. Note that in either case the columns will be logical unless `colClasses` was supplied.

Character strings in the result (including factor levels) will have a declared encoding if `encoding` is `"latin1"` or `"UTF-8"`.

### CSV files

See the help on [`write.csv`](http://127.0.0.1:45439/help/library/utils/help/write.csv) for the various conventions for `.csv` files. The commonest form of CSV file with row names needs to be read with `read.csv(..., row.names = 1)` to use the names in the first column of the file as row names.

### Memory usage

These functions can use a surprising amount of memory when reading large files. There is extensive discussion in the ‘R Data Import/Export’ manual, supplementing the notes here.

Less memory will be used if `colClasses` is specified as one of the six [atomic](http://127.0.0.1:45439/help/library/utils/help/atomic) vector classes. This can be particularly so when reading a column that takes many distinct numeric values, as storing each distinct value as a character string can take up to 14 times as much memory as storing it as an integer.

Using `nrows`, even as a mild over-estimate, will help memory usage.

Using `comment.char = ""` will be appreciably faster than the `read.table` default.

`read.table` is not the right tool for reading large matrices, especially those with many columns: it is designed to read *data frames* which may have columns of very different classes. Use [`scan`](http://127.0.0.1:45439/help/library/utils/help/scan) instead for matrices.

### Note

The columns referred to in `as.is` and `colClasses` include the column of row names (if any).

There are two approaches for reading input that is not in the local encoding. If the input is known to be UTF-8 or Latin1, use the `encoding` argument to declare that. If the input is in some other encoding, then it may be translated on input. The `fileEncoding` argument achieves this by setting up a connection to do the re-encoding into the current locale. Note that on Windows or other systems not running in a UTF-8 locale, this may not be possible.

### References

Chambers, J. M. (1992) *Data for models.* Chapter 3 of *Statistical Models in S* eds J. M. Chambers and T. J. Hastie, Wadsworth & Brooks/Cole.

### See Also

The ‘R Data Import/Export’ manual.

[`scan`](http://127.0.0.1:45439/help/library/utils/help/scan), [`type.convert`](http://127.0.0.1:45439/help/library/utils/help/type.convert), [`read.fwf`](http://127.0.0.1:45439/help/library/utils/help/read.fwf) for reading *f*ixed *w*idth *f*ormatted input; [`write.table`](http://127.0.0.1:45439/help/library/utils/help/write.table); [`data.frame`](http://127.0.0.1:45439/help/library/utils/help/data.frame).

[`count.fields`](http://127.0.0.1:45439/help/library/utils/help/count.fields) can be useful to determine problems with reading files which result in reports of incorrect record lengths (see the ‘Examples’ below).

<https://www.rfc-editor.org/rfc/rfc4180> for the IANA definition of CSV files (which requires comma as separator and CRLF line endings).

**Examples**

[Run examples](http://127.0.0.1:45439/help/library/utils/Example/read.table)

```         
## using count.fields to handle unknown maximum number of fields ## when fill = TRUE test1 <- c(1:5, "6,7", "8,9,10") tf <- tempfile() writeLines(test1, tf)  read.csv(tf, fill = TRUE) # 1 column ncol <- max(count.fields(tf, sep = ",")) read.csv(tf, fill = TRUE, header = FALSE,          col.names = paste0("V", seq_len(ncol))) unlink(tf)  ## "Inline" data set, using text= ## Notice that leading and trailing empty lines are auto-trimmed  read.table(header = TRUE, text = " a b 1 2 3 4 ") 
```

[Package *utils* version 4.4.2 [Index](http://127.0.0.1:45439/help/library/utils/html/00Index.html)]

------------------------------------------------------------------------

# Chapter 2: `readr` and `data.table`

## Video 2.1: `read_csv` & `read_tsv`

### Overview

-   Before: `utils` package

-   Specific R packages

    -   `readr`

    -   `data.table`

### `readr`

-   Hadley Wickham

-   Fast, easy to use, consistent

-   `utils`: verbose, slower

```{r}
# install.packages("readr")
library(readr)
```

### Wrapping in `utils` and `readr`

-   Just like in `utils`, both the `read_csv` and `read_tsv` functions are wrappers around a "mother import function" called `read_delim`

![](images/wrapping-in-utils-and-readr.png)

## **read_csv**

CSV files can be imported with `read_csv()`. It's a wrapper function around `read_delim()` that handles all the details for you. For example, it will assume that the first row contains the column names.

The dataset you'll be working with here is `potatoes.csv` ([**view**](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.csv)). It gives information on the impact of storage period and cooking on potatoes' flavor. It uses commas to delimit fields in a record, and contains column names in the first row. The file is available in your workspace. Remember that you can inspect your workspace with `dir()`.

**Instructions**

-   Load the `readr` package with `library()`. You **do not** need to install the package, it is already installed on DataCamp's servers.

-   Import `"potatoes.csv"` using `read_csv()`. Assign the resulting data frame to the variable `potatoes`.

```{r}
# Load the readr package
library(readr)

# Import potatoes.csv with read_csv(): potatoes
potatoes <- read_csv("datasets/potatoes.csv")
```

## **read_tsv**

Where you use `read_csv()` to easily read in CSV files, you use `read_tsv()` to easily read in TSV files. TSV is short for tab-separated values.

This time, the potatoes data comes in the form of a tab-separated values file; `potatoes.txt` ([**view**](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.txt)) is available in your workspace. In contrast to `potatoes.csv`, this file does **not** contain columns names in the first row, though.

There's a vector `properties` that you can use to specify these column names manually.

**Instructions**

-   Use `read_tsv()` to import the potatoes data from `potatoes.txt` and store it in the data frame `potatoes`. In addition to the path to the file, you'll also have to specify the `col_names` argument; you can use the `properties` vector for this.

-   Call `head()` on `potatoes` to show the first observations of your dataset.

```{r}
# readr is already loaded

# Column names
properties <- c("area", 
                "temp", 
                "size", 
                "storage", 
                "method",
                "texture", 
                "flavor", 
                "moistness"
                )

# Import potatoes.txt: potatoes
potatoes <- read_tsv("datasets/potatoes.txt", 
                     col_names = properties)

# Call head() on potatoes
head(potatoes)
```

## Video 2.2: `readr`: `read_delim`

```         
states2.txt

state/capital/pop_mill/area_sqm
South Dakota/Pierre/0.853/77116
New York/Albany/19.746/54555
Oregon/Salem/3.970/98381
Vermont/Montpelier/0.627/9616
Hawaii/Honolulu/1.420/10931
```

### `states2.txt`

```{r}
# utils
read.table("datasets/states2.txt",
           header = TRUE,
           sep = "/")
```

```{r}
# readr
read_delim("datasets/states2.txt",
           delim = "/")
```

```         
states3.txt

South Dakota/Pierre/0.853/77116
New York/Albany/19.746/54555
Oregon/Salem/3.970/98381
Vermont/Montpelier/0.627/9616
Hawaii/Honolulu/1.420/10931
```

### `col_names`

```{r}
read_delim("datasets/states3.txt", 
           delim = "/",
           col_names = FALSE)
```

```{r}
read_delim("datasets/states3.txt",
           delim = "/",
           col_names = c("state",
                         "city",
                         "pop",
                         "area"
                         )
           )
```

### `col_types`

```{r}
read_delim("datasets/states2.txt",
           delim = "/")
```

```{r}
read_delim("datasets/states2.txt",
           delim = "/",
           col_types = "ccdd")
```

### `skip` and `nmax`

```{r}
read_delim("datasets/states2.txt",
           delim = "/",
           skip = 2,
           n_max = 3
           )
```

```{r}
read_delim("datasets/states2.txt",
           delim = "/",
           skip = 2,
           n_max = 3
           )
```

## **read_delim**

Just as `read.table()` was the main `utils` function, `read_delim()` is the main `readr` function.

`read_delim()` takes two mandatory arguments:

-   `file`: the file that contains the data

-   `delim`: the character that separates the values in the data file

You'll again be working with `potatoes.txt` ([**view**](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.txt)); the file uses tabs (`"\t"`) to delimit values and does **not** contain column names in its first line. It's available in your working directory so you can start right away. As before, the vector `properties` is available to set the `col_names`.

**Instructions**

-   Import all the data in `"potatoes.txt"` using `read_delim()`; store the resulting data frame in `potatoes`.

-   Print out `potatoes`.

```{r}
# readr is already loaded

# Column names
properties <- c("area", 
                "temp", 
                "size", 
                "storage", 
                "method",
                "texture", 
                "flavor", 
                "moistness"
                )

# Import potatoes.txt using read_delim(): potatoes
potatoes <- read_delim("datasets/potatoes.txt", 
                       delim="\t", 
                       col_names = properties
                       )

# Print out potatoes
print(potatoes)
```

## **skip and n_max**

Through `skip` and `n_max` you can control *which part* of your flat file you're actually importing into R.

-   `skip` specifies the number of lines you're ignoring in the flat file before actually starting to import data.

-   `n_max` specifies the number of lines you're actually importing.

Say for example you have a CSV file with 20 lines, and set `skip = 2` and `n_max = 3`, you're only reading in lines 3, 4 and 5 of the file.

Watch out: Once you `skip` some lines, you also skip the first line that can contain column names!

`potatoes.txt` ([**view**](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.txt)), a flat file with tab-delimited records and without column names, is available in your workspace.

**Instructions**

-   Finish the first `read_tsv()` call to import observations 7, 8, 9, 10 and 11 from `potatoes.txt`.

```{r}
# readr is already loaded

# Column names
properties <- c("area", 
                "temp", 
                "size", 
                "storage", 
                "method",
                "texture", 
                "flavor", 
                "moistness"
                )

# Import 5 observations from potatoes.txt: potatoes_fragment
potatoes_fragment <- read_tsv("datasets/potatoes.txt", 
                              skip = 6, 
                              n_max = 5, 
                              col_names = properties
                              )
```

## **col_types**

You can also specify which types the columns in your imported data frame should have. You can do this with `col_types`. If set to `NULL`, the default, functions from the `readr` package will try to find the correct types themselves. You can manually set the types with a string, where each character denotes the class of the column: `c`haracter, `d`ouble, `i`nteger and `l`ogical. `_` skips the column as a whole.

`potatoes.txt` ([**view**](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.txt)), a flat file with tab-delimited records and without column names, is again available in your workspace.

**Instructions**

-   In the second `read_tsv()` call, edit the `col_types` argument to import *all* columns as characters (`c`). Store the resulting data frame in `potatoes_char`.

-   Print out the structure of `potatoes_char` and verify whether all column types are `chr`, short for `character`.

```{r}
# readr is already loaded

# Column names
properties <- c("area", 
                "temp", 
                "size", 
                "storage", 
                "method",
                "texture", 
                "flavor", 
                "moistness"
                )

# Import all data, but force all columns to be character: potatoes_char
potatoes_char <- read_tsv("potatoes.txt", 
                          col_types = "cccccccc", 
                          col_names = properties
                          )

# Print out structure of potatoes_char
print(str(potatoes_char))
```

## **col_types with collectors**

Another way of setting the types of the imported columns is using **collectors**. Collector functions can be passed in a `list()` to the `col_types` argument of `read_` functions to tell them how to interpret values in a column.

For a complete list of collector functions, you can take a look at the `collector` documentation. For this exercise you will need two collector functions:

-   `col_integer()`: the column should be interpreted as an integer.

-   `col_factor(levels, ordered = FALSE)`: the column should be interpreted as a factor with `levels`.

In this exercise, you will work with `hotdogs.txt` ([**view**](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/hotdogs.txt)), which is a tab-delimited file without column names in the first row.

**Instructions**

-   `hotdogs` is created for you without setting the column types. Inspect its summary using the `summary()` function.

-   Two collector functions are defined for you: `fac` and `int`. Have a look at them, do you understand what they're collecting?

-   In the second `read_tsv()` call, edit the `col_types` argument: Pass a `list()` with the elements `fac`, `int` and `int`, so the first column is imported as a factor, and the second and third column as integers.

-   Create a `summary()` of `hotdogs_factor`. Compare this to the summary of `hotdogs`.

```{r}
# readr is already loaded

# Import without col_types
hotdogs <- read_tsv("datasets/hotdogs.txt", 
                    col_names = c("type", 
                                  "calories", 
                                  "sodium"
                                  )
                    )

# Display the summary of hotdogs
summary(hotdogs)

# The collectors you will need to import the data
fac <- col_factor(levels = c("Beef", 
                             "Meat", 
                             "Poultry"
                             )
                  )

int <- col_integer()

# Edit the col_types argument to import the data correctly: hotdogs_factor
hotdogs_factor <- read_tsv("datasets/hotdogs.txt",
                           col_names = c("type", 
                                         "calories", 
                                         "sodium"
                                         ),
                           col_types = list(fac, 
                                            int, 
                                            int
                                            )
                           )

# Display the summary of hotdogs_factor
summary(hotdogs_factor)
```

## Video 2.3: `data.table`: `fread`

### `data.table`

-   Matt Dowle & Arun Srinivasan

-   Key metric: speed

-   Data manipulation in R

-   Function to import data: `fread()`

```{r}
# install.packages("data.table")
library(data.table)
```

-   Similar to `read.table()`

```         
states.csv

state,capital,pop_mill,area_sqm
South Dakota,Pierre,0.853,77116
New York,Albany,19.746,54555
Oregon,Salem,3.970,98381
Vermont,Montpelier,0.627,9616
Hawaii,Honolulu,1.420,10931

states2.csv

South Dakota,Pierre,0.853,77116
New York,Albany,19.746,54555
Oregon,Salem,3.970,98381
Vermont,Montpelier,0.627,9616
Hawaii,Honolulu,1.420,10931
```

### `fread()`

-   Infer column types and separators

-   It simply works

-   Extremely, ridiculously fast

-   Possible to specify numerous parameters

-   Improved `read.table()`

-   Fast, convenient, customizable

## **fread**

You still remember how to use `read.table()`, right? Well, `fread()` is a function that does the same job with very similar arguments. It is extremely easy to use and blazingly fast! Often, simply specifying the path to the file is enough to successfully import your data.

Don't take our word for it, try it yourself! You'll be working with the `potatoes.csv` ([**view**](http://s3.amazonaws.com/assets.datacamp.com/production/course_1477/datasets/potatoes.csv)) file, that's available in your workspace. Fields are delimited by commas, and the first line contains the column names.

**Instructions**

-   Use `library()` to load (NOT install) the `data.table` package. You **do not** need to install the package, it is already installed on DataCamp's servers.

-   Import `"potatoes.csv"` with `fread()`. Simply pass it the file path and see if it worked. Store the result in a variable `potatoes`.

-   Print out `potatoes`.

```{r}
# load the data.table package using library()
library(data.table)

# Import potatoes.csv with fread(): potatoes
potatoes <- fread("potatoes.csv")

# Print out potatoes
print(potatoes)
```
