---
title: "DataCamp_Intermediate-Data-Visualization-with-ggplot2"
output: html_notebook
student: "Andrex Ibiza, MBA"
date: 2025-02-11
---

# Chapter 1: Statistics

A picture paints a thousand words, which is why R ggplot2 is such a powerful tool for graphical data analysis. In this chapter, youâ€™ll progress from simply plotting data to applying a variety of statistical methods. These include a variety of linear models, descriptive and inferential statistics (mean, standard deviation and confidence intervals) and custom functions.

## Video 1.1: Stats with geoms

### ggplot2, course 2

-   Statistics
-   Coordinates
-   Facets
-   Data Visualization Best Practices

### Statistics layer

-   Two categories of functions:
    -   Called from within a geom
    -   Called independently
-   `stats_` : all statistical functions begin with this prefix.
    -   even from within the geom layer, they can be called independently in this way.

### `geom_` \<-\> `stat_`

```{r}
library(tidyverse)
p <- ggplot(iris, aes(x = Sepal.Width))
p + geom_histogram()
```

```{r}
p <- ggplot(iris, aes(x = Sepal.Width))
p + geom_histogram()
p + geom_bar()
```

```{r}
p <- ggplot(mtcars, aes(x = factor(cyl),  fill = factor(am)))
p + geom_bar()
p + stat_count()
```

| `stat_`        | `geom_`                               |
|----------------|---------------------------------------|
| `stat_bin`     | `geom_histogram()`, `geom_freqpoly()` |
| `stat_count()` | `geom_bar()`                          |

### `stat_smooth()`

```{r}
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
  geom_point() +
  stat_smooth()

# geom_smooth() using method = 'loess' and formula 'y ~ x'
```

### `stat_smooth(se = FALSE)`

```{r}
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
  geom_point() +
  stat_smooth(se = FALSE)

# geom_smooth() using method = 'loess' and formula 'y ~ x'
# loess is a nonparametric smoothing algorithm used when there are less than 1000 observations. creates weighted mean that creates sliding window along x-axis and is valuable for exploratory data analysis.
```

### `geom_smooth(span = 0.4)`

```{r}
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
  geom_point() +
  stat_smooth(se = FALSE, span = 0.4)

# geom_smooth() using method = 'loess' and formula 'y ~ x'
# the `span` argument controls the degree of smoothing, which is the size of the sliding window.
```

### `geom_smooth(method = "lm")`

```{r}
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
  geom_point() +
  stat_smooth(method = "lm", se = FALSE)
```

### `geom_smooth(fullrange = TRUE)`

```{r}
ggplot(iris, aes(x = Sepal.Length,
                 y = Sepal.Width,
                 color = Species)) +
  geom_point() +
  geom_smooth(method = "lm", 
              fullrange = TRUE)
```

| `stat_` | `geom_` |
|------------------------------------|------------------------------------|
| `stat_bin` | `geom_histogram()`, `geom_freqpoly() | |`stat_count()`|`geom_bar()`| |`stat_smooth()`|`geom_smooth()\` |

### Other `stat_` functions

| `stat_`           | `geom_`           |
|-------------------|-------------------|
| `stat_boxplot()`  | `geom_boxplot()`  |
| `stat_bindot()`   | `geom_dotplot()`  |
| `stat_bin2d()`    | `geom_bin2d()`    |
| `stat_binhex()`   | `geom_hex()`      |
| `stat_contour()`  | `geom_contour()`  |
| `stat_quantile()` | `geom_quantile()` |
| `stat_sum()`      | `geom_count()`    |

### Exercise: Modifying `stat_smooth`

In the previous exercise we used `se = FALSE` in `stat_smooth()` to remove the 95% Confidence Interval. Here we'll consider another argument, span, used in LOESS smoothing, and we'll take a look at a nice scenario of properly mapping different models.

#### Instructions 1/3
33 XP
Explore the effect of the span argument on LOESS curves. Add three smooth LOESS stats, each without the standard error ribbon.

Color the 1st one "red"; set its span to 0.9.
Color the 2nd one "green"; set its span to 0.6.
Color the 3rd one "blue"; set its span to 0.3.
Compare LOESS and linear regression smoothing on small regions of data.
```{r}
ggplot(mtcars, aes(x = wt, y = mpg)) +
  geom_point() +
  # Add 3 smooth LOESS stats, varying span & color
  stat_smooth(color = "red", span = 0.9, se = FALSE) +
  stat_smooth(color = "green", span = 0.6, se = FALSE) +
  stat_smooth(color = "blue", span = 0.3, se = FALSE)
```

#### 2/3
Add a smooth LOESS stat, without the standard error ribbon.
Add a smooth linear regression stat, again without the standard error ribbon.
```{r}
# Amend the plot to color by fcyl
ggplot(mtcars, aes(x = wt, y = mpg)) +
  geom_point() +
  # Add a smooth LOESS stat, no ribbon
  stat_smooth(se = FALSE) +
  # Add a smooth lin. reg. stat, no ribbon
  stat_smooth(method = "lm", se = FALSE)
```


#### 3/3
LOESS isn't great on very short sections of data; compare the pieces of linear regression to LOESS over the whole thing.

Amend the smooth LOESS stat to map color to a dummy variable, "All".
```{r}
# Amend the plot
ggplot(mtcars, aes(x = wt, y = mpg, color = cyl)) +
  geom_point() +
  # Map color to dummy variable "All"
  stat_smooth(aes(color = "All"), se = FALSE) +
  stat_smooth(method = "lm", se = FALSE)
```



### Smoothing
Smoothing
To practice on the remaining layers (statistics, coordinates and facets), we'll continue working on several datasets from the first course.

The mtcars dataset contains information for 32 cars from Motor Trends magazine from 1974. This dataset is small, intuitive, and contains a variety of continuous and categorical (both nominal and ordinal) variables.

In the previous course you learned how to effectively use some basic geometries, such as point, bar and line. In the first chapter of this course you'll explore statistics associated with specific geoms, for example, smoothing and lines.

#### Instructions 1/4
25 XP
Look at the structure of mtcars.
Using mtcars, draw a scatter plot of mpg vs. wt.
```{r}
# View the structure of mtcars
str(mtcars)

# Using mtcars, draw a scatter plot of mpg vs. wt
ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
```
#### 2/4
Update the plot to add a smooth trend line. Use the default method, which uses the LOESS model to fit the curve.
```{r}
# Amend the plot to add a smooth layer
ggplot(mtcars, aes(x = wt, y = mpg)) +
  geom_point() +
  geom_smooth()
```
#### 3/4
Update the smooth layer. Apply a linear model by setting method to "lm", and turn off the model's 95% confidence interval (the ribbon) by setting se to FALSE.
```{r}
# Amend the plot. Use lin. reg. smoothing; turn off std err ribbon
ggplot(mtcars, aes(x = wt, y = mpg)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)
```
#### 4/4
Draw the same plot again, swapping geom_smooth() for stat_smooth().
```{r}
# Amend the plot. Swap geom_smooth() for stat_smooth().
ggplot(mtcars, aes(x = wt, y = mpg)) +
  geom_point() +
  stat_smooth(method = "lm", se = FALSE)
```
### Grouping Variables
We'll continue with the previous exercise by considering the situation of looking at sub-groups in our dataset. For this we'll encounter the invisible group aesthetic.

mtcars has been given an extra column, fcyl, that is the cyl column converted to a proper factor variable.

Instructions 1/2
50 XP
Using mtcars, plot mpg vs. wt, colored by fcyl.
Add a point layer.
Add a smooth stat using a linear model, and don't show the se ribbon.

```{r}
# Using mtcars, plot mpg vs. wt, colored by fcyl
ggplot(mtcars, aes(x = wt, y = mpg, color = cyl)) +
  # Add a point layer
  geom_point() +
  # Add a smooth lin reg stat, no ribbon
  stat_smooth(method = "lm", se = FALSE)
```
```{r}
# Amend the plot to add another smooth layer with dummy grouping
ggplot(mtcars, aes(x = wt, y = mpg, color = cyl)) +
  geom_point() +
  stat_smooth(method = "lm", se = FALSE) +
  stat_smooth(aes(group = 1), method = "lm", se = FALSE)
```



## Video 1.2: Stats: sum and quantile

### Recall from course 1

|   | Cause of Over-plotting | Solutions |
|--------------|-----------------------------|-----------------------------|
| 1 | Large datasets | Alpha-blending, hollow circles, and point size |
| 2 | Aligned values on a single axis | As above, plus change position |
| 3 | Low-precision data | Position: jitter |
| 4 | Integer data | Position: jitter |

### Plot counts to overcome over-plotting

|   | Cause of Over-plotting | Solutions | Here |
|---------------|-------------------|-------------------|-------------------|
| 1 | Large datasets | Alpha-blending, hollow circles, and point size |  |
| 2 | Aligned values on a single axis | As above, plus change position |  |
| 3 | Low-precision data | Position: jitter | `geom_count()` |
| 4 | Integer data | Position: jitter | `geom_count()` |

### Low precision (& integer) data

```{r}
p <- ggplot(iris, aes(Sepal.Length, Sepal.Width))
p + geom_point() + ggtitle("Low precision (& integer) data")
```

### Jittering may give a wrong impression

```{r}
p + geom_jitter(alpha = 0.5,
                width = 0.1,
                height = 0.1) +
  ggtitle("Jittering may give a wrong impression")
```

### `geom_count()`

```{r}
p + geom_count() + ggtitle("geom_count()")
```
## Video 1.3: Stats outside geoms

### Basic plot
```{r}
ggplot(iris, aes(x = Species,
                 y = Sepal.Length)) +
  geom_jitter(width = 0.2)
```
### Calculating statistics
```{r}
set.seed(123)
xx <- rnorm(100)
mean(xx)
```
```{r}
mean(xx) + (sd(xx) * c(-1, 1))
```
```{r}
# Hmisc
library(Hmisc)
smean.sdl(xx, mult = 1)
```
```{r}
# ggplot2
mean_sdl(xx, mult = 1)
```
### `stat_summary()`
* Uses `geom_pointrange()` by default

```{r}
ggplot(iris, aes(x = Species,
                 y = Sepal.Length)) +
  stat_summary(fun.data = mean_sdl,
               fun.args = list(mult = 1))
```

```{r}
ggplot(iris, aes(x = Species,                 
                 y = Sepal.Length)) +  
  stat_summary(fun = mean,               
               geom = "point") +  
  stat_summary(fun.data = mean_sdl,               
               fun.args = list(mult =1),               
               geom = "errorbar",               
               width = 0.1)
```

### 95% confidence interval
```{r}
ERR <- qt(0.975, length(xx) - 1) * sd(xx) / sqrt(length(xx))
mean(xx)
# [1] 0.09040591

mean(xx) + (ERR * c(-1, 1)) # 95% CI
# [1] -0.09071657  0.27152838

mean_cl_normal(xx)
```
### Other `stat_` functions

| `stat_`           | Description           |
| ------------------|-----------------------|
| `stat_summary()`  | Summarize y values at distinct x values    |
| `stat_function()` | Compute y values from a function of x values |
| `stat_qq()`       | Perform calculations for a quantile-quantile plot |


### Normal distribution
```{r}
library(MASS)
mam.new <- data.frame(body = log10(mammals$body))

ggplot(mam.new, aes(x = body)) +
  geom_histogram(aes(y = ..density..)) +
  geom_rug() +
  stat_function(fun = dnorm, color = "red", args = list(mean = mean(mam.new$body), 
                                                        sd = sd(mam.new$body)))
```

### Quantile-quantile (QQ) plot
```{r}
ggplot(mam.new, aes(sample = body)) +
  stat_qq() +
  geom_qq_line(col = "red")
```
#### Preparations
In the following exercises, we'll aim to make the plot shown in the viewer. Here, we'll establish our positions and base layer of the plot.

Establishing these items as independent objects will allow us to recycle them easily in many layers, or plots.

* `position_jitter()` adds jittering (e.g. for points).
* `position_dodge()` dodges geoms, (e.g. bar, col, boxplot, violin, errorbar, pointrange).
* `position_jitterdodge()` jitters and dodges geoms, (e.g. points).
As before, we'll use `mtcars`, where `fcyl` and `fam` are proper factor variables of the original `cyl` and `am` variables.

##### Instructions 1/2
50 XP
1/2
Using these three functions, define these position objects:
* `posn_j`: will jitter with a width of 0.2.
* `posn_d`: will dodge with a width of 0.1.
* `posn_jd` will jitter and dodge with a jitter.width of 0.2 and a dodge.width of 0.1.

```{r}
# Define position objects
# 1. Jitter with width 0.2
posn_j <- position_jitter(width = 0.2)

# 2. Dodge with width 0.1
posn_d <- position_dodge(width = 0.1)

# 3. Jitter-dodge with jitter.width 0.2 and dodge.width 0.1
posn_jd <- position_jitterdodge(jitter.width = 0.2, dodge.width = 0.1)
```

##### Instructions 2/2
50 XP
2/2

Plot `wt` vs. `fcyl`, colored by `fam`. Assign this base layer to `p_wt_vs_fcyl_by_fam`.

Plot the data using `geom_point()`.
```{r}
# From previous step
posn_j <- position_jitter(width = 0.2)
posn_d <- position_dodge(width = 0.1)
posn_jd <- position_jitterdodge(jitter.width = 0.2, dodge.width = 0.1)

# Create the plot base: wt vs. fcyl, colored by fam
p_wt_vs_fcyl_by_fam <- ggplot(mtcars, aes(x = cyl, y = wt, color = am))

# Add a point layer
p_wt_vs_fcyl_by_fam +
  geom_point()
```
### Using position objects

Now that the position objects have been created, you can apply them to the base plot to see their effects. You do this by adding a point geom and setting the position argument to the position object.

The variables from the last exercise, posn_j, posn_d, posn_jd, and p_wt_vs_fcyl_by_fam are available in your workspace.

##### Instructions 1/3
35 XP
Apply the jitter position, posn_j, to the base plot.

```{r}
# Add jittering only
p_wt_vs_fcyl_by_fam_jit <- p_wt_vs_fcyl_by_fam +
  geom_point(position = posn_j)
p_wt_vs_fcyl_by_fam_jit
```

2/3
Apply the dodge position, posn_d, to the base plot.
```{r}
# Add dodging only
p_wt_vs_fcyl_by_fam +
  geom_point(position = posn_d)
```

3/3
Apply the jitter-dodge position, posn_jd, to the base plot.

```{r}
# Add jittering and dodging
p_wt_vs_fcyl_by_fam +
  geom_point(position = posn_jd)
```

### Plotting variations

The preparation is done; now let's explore stat_summary().

Summary statistics refers to a combination of location (mean or median) and spread (standard deviation or confidence interval).

These metrics are calculated in stat_summary() by passing a function to the fun.data argument. mean_sdl(), calculates multiples of the standard deviation and mean_cl_normal() calculates the t-corrected 95% CI.

Arguments to the data function are passed to stat_summary()'s fun.args argument as a list.

The position object, posn_d, and the plot with jittered points, p_wt_vs_fcyl_by_fam_jit, are available.

#### Instructions 1/3
33 XP
Add error bars representing the standard deviation.
Set the data function to mean_sdl (without parentheses).
Draw 1 standard deviation each side of the mean, pass arguments to the mean_sdl() function by assigning them to fun.args in the form of a list.
Use posn_d to set the position.

```{r}
p_wt_vs_fcyl_by_fam_jit + 
  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), position = posn_d)
```
##### 2/2
The default geom for stat_summary() is "pointrange" which is already great.

Update the summary stat to use an "errorbar" geom by assigning it to the geom argument.
```{r}
p_wt_vs_fcyl_by_fam_jit +
  # Change the geom to be an errorbar
  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1), position = posn_d, geom = "errorbar")
```

##### 3/3
Update the plot to add a summary stat of 95% confidence limits.
Set the data function to mean_cl_normal (without parentheses).
Again, use the dodge position.
```{r}
p_wt_vs_fcyl_by_fam_jit +
  # Add a summary stat of normal confidence limits
  stat_summary(fun.data = mean_cl_normal,
  fun.args = list(mult = 1),
  geom = "errorbar",
  position = posn_d)
```


# Chapter 2: Coordinates

## Video 2.1: Coordinates



